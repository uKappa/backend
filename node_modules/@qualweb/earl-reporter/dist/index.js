"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateEARLReport = exports.generateEARLAssertions = void 0;
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const constants_1 = require("./constants");
function generateEARLAssertions(report, date) {
    var _a;
    const assertions = new Array();
    for (const name in report.assertions || {}) {
        if (report.assertions[name]) {
            const test = report.assertions[name];
            if (test) {
                const sources = generateSources(test);
                const sCriterias = test.metadata['success-criteria'];
                const isPartOf = convertSC(sCriterias);
                const result = {
                    '@type': 'TestResult',
                    outcome: 'earl:' + (test.metadata.outcome !== 'warning' ? test.metadata.outcome : 'cantTell'),
                    source: sources,
                    description: test.metadata.description,
                    date: date !== null && date !== void 0 ? date : new Date().toISOString().replace(/T/, ' ').replace(/\..+/, '')
                };
                const assertion = {
                    '@type': 'Assertion',
                    test: {
                        '@id': (_a = test.metadata.url) !== null && _a !== void 0 ? _a : test.name,
                        '@type': 'TestCase',
                        title: test.name,
                        description: test.description,
                        isPartOf
                    },
                    mode: 'earl:automatic',
                    result
                };
                assertions.push(assertion);
            }
        }
    }
    return assertions;
}
exports.generateEARLAssertions = generateEARLAssertions;
function convertSC(scList) {
    if (scList)
        return scList.map((sc) => {
            var _a;
            const name = sc.name;
            return (_a = constants_1.SC[name]) === null || _a === void 0 ? void 0 : _a.scId;
        });
    else
        return [];
}
function generateSources(test) {
    var _a;
    const sources = new Array();
    for (const result of test.results || []) {
        const source = {
            result: {
                pointer: (_a = result.elements) === null || _a === void 0 ? void 0 : _a.filter((e) => e.pointer !== undefined).map((e) => e.pointer).join(', '),
                outcome: 'earl:' + (result.verdict !== 'warning' ? result.verdict : 'cantTell')
            }
        };
        sources.push(source);
    }
    return sources;
}
function reportModule(module, options) {
    if (!options || !options.modules) {
        return true;
    }
    else {
        switch (module) {
            case 'act':
                return !!options.modules.act;
            case 'wcag':
                return !!options.modules.wcag;
            case 'best-practices':
                return !!options.modules['best-practices'];
            default:
                return false;
        }
    }
}
function generateSingleEarlReport(report, options) {
    var _a, _b;
    const earlReport = {
        '@context': 'https://act-rules.github.io/earl-context.json',
        '@graph': new Array()
    };
    const assertor = {
        '@id': report.system.name,
        '@type': 'Software',
        title: report.system.name,
        description: report.system.description,
        hasVersion: report.system.version,
        homepage: report.system.homepage
    };
    const testSubject = {
        '@type': 'TestSubject',
        source: (_b = (_a = report.system.url) === null || _a === void 0 ? void 0 : _a.inputUrl) !== null && _b !== void 0 ? _b : '',
        assertor,
        assertions: new Array()
    };
    if (report.system.url && report.system.url.inputUrl !== report.system.url.completeUrl) {
        testSubject.redirectedTo = report.system.url.completeUrl;
    }
    if (report.modules['act-rules'] && reportModule('act', options)) {
        testSubject.assertions = [
            ...testSubject.assertions,
            ...generateEARLAssertions(report.modules['act-rules'], report.system.date)
        ];
    }
    if (report.modules['wcag-techniques'] && reportModule('wcag', options)) {
        testSubject.assertions = [
            ...testSubject.assertions,
            ...generateEARLAssertions(report.modules['wcag-techniques'], report.system.date)
        ];
    }
    if (report.modules['best-practices'] && reportModule('best-practices', options)) {
        testSubject.assertions = [
            ...testSubject.assertions,
            ...generateEARLAssertions(report.modules['best-practices'], report.system.date)
        ];
    }
    earlReport['@graph'].push(lodash_clonedeep_1.default(testSubject));
    return earlReport;
}
function generateAggregatedEarlReport(reports, options) {
    const aggregatedReport = {
        '@context': 'https://act-rules.github.io/earl-context.json',
        '@graph': new Array()
    };
    for (const report of reports || []) {
        const earlReport = generateSingleEarlReport(report, options);
        aggregatedReport['@graph'].push(lodash_clonedeep_1.default(earlReport['@graph'][0]));
    }
    return aggregatedReport;
}
function generateEARLReport(reports, options) {
    const earlReports = {};
    if (options && options.aggregated) {
        const firstUrl = Object.keys(reports)[0];
        earlReports[options.aggregatedName || firstUrl] = generateAggregatedEarlReport(Object.values(reports), options);
    }
    else {
        for (const url in reports || {}) {
            const earlReport = generateSingleEarlReport(reports[url], options);
            earlReports[url] = lodash_clonedeep_1.default(earlReport);
        }
    }
    return lodash_clonedeep_1.default(earlReports);
}
exports.generateEARLReport = generateEARLReport;
//# sourceMappingURL=index.js.map