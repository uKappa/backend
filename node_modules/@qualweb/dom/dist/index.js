"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dom = void 0;
const constants_1 = require("./constants");
const url_1 = require("url");
const axios_1 = __importDefault(require("axios"));
class Dom {
    constructor(page, validator) {
        this.page = page;
        this.endpoint = validator;
    }
    async process(options, url, html) {
        var _a, _b;
        url = this.removeUrlAnchor(url);
        await this.page.setBypassCSP(true);
        await this.setPageViewport(options.viewport);
        const needsValidator = this.validatorNeeded(options);
        const needsPreprocessedHTML = this.sourceHTMLNeeded(options);
        let validation;
        let response;
        let sourceHtml = '';
        if (url) {
            if (needsValidator && needsPreprocessedHTML) {
                [response, validation, sourceHtml] = await Promise.all([
                    this.navigateToPage(url, options),
                    this.getValidatorResult(url),
                    this.getSourceHtml(url, options.viewport)
                ]);
            }
            else if (needsValidator) {
                [response, validation] = await Promise.all([this.navigateToPage(url, options), this.getValidatorResult(url)]);
            }
            else if (needsPreprocessedHTML) {
                [response, sourceHtml] = await Promise.all([
                    this.navigateToPage(url, options),
                    this.getSourceHtml(url, options.viewport)
                ]);
            }
            else {
                response = await this.navigateToPage(url, options);
            }
            const sourceHTMLPuppeteer = await (response === null || response === void 0 ? void 0 : response.text());
            if (!this.isHtmlDocument(sourceHTMLPuppeteer, url)) {
                await this.page.goBack();
                await this.page.setContent('<!DOCTYPE html><html nonHTMLPage=true><body></body></html>', {
                    timeout: options.timeout
                });
            }
        }
        else if (html) {
            await this.page.setContent(html, {
                timeout: (_a = options.timeout) !== null && _a !== void 0 ? _a : 60 * 1000,
                waitUntil: (_b = options.waitUntil) !== null && _b !== void 0 ? _b : 'load'
            });
            sourceHtml = await this.page.content();
        }
        else {
            throw new Error('Neither a url nor html content was provided.');
        }
        return {
            sourceHtml,
            validation
        };
    }
    removeUrlAnchor(url) {
        if (url) {
            const urlObject = new url_1.URL(url);
            return urlObject.origin + urlObject.pathname + urlObject.search;
        }
        return url;
    }
    async navigateToPage(url, options) {
        var _a, _b;
        this.page.on('dialog', async (dialog) => {
            await dialog.dismiss();
        });
        return this.page.goto(url, {
            timeout: (_a = options.timeout) !== null && _a !== void 0 ? _a : 240 * 1000,
            waitUntil: (_b = options.waitUntil) !== null && _b !== void 0 ? _b : 'load'
        });
    }
    async setPageViewport(options) {
        if (options) {
            if (options.userAgent) {
                await this.page.setUserAgent(options.userAgent);
            }
            else if (options.mobile) {
                await this.page.setUserAgent(constants_1.DEFAULT_MOBILE_USER_AGENT);
            }
            else {
                await this.page.setUserAgent(constants_1.DEFAULT_DESKTOP_USER_AGENT);
            }
            await this.page.setViewport(this.createViewportObject(options));
        }
        else {
            await this.page.setViewport({
                width: constants_1.DEFAULT_DESKTOP_PAGE_VIEWPORT_WIDTH,
                height: constants_1.DEFAULT_DESKTOP_PAGE_VIEWPORT_HEIGHT,
                isMobile: false,
                hasTouch: false,
                isLandscape: true
            });
        }
    }
    createViewportObject(options) {
        var _a, _b, _c;
        const viewPort = {
            width: options.mobile ? constants_1.DEFAULT_MOBILE_PAGE_VIEWPORT_WIDTH : constants_1.DEFAULT_DESKTOP_PAGE_VIEWPORT_WIDTH,
            height: options.mobile ? constants_1.DEFAULT_MOBILE_PAGE_VIEWPORT_HEIGHT : constants_1.DEFAULT_DESKTOP_PAGE_VIEWPORT_HEIGHT
        };
        if ((_a = options.resolution) === null || _a === void 0 ? void 0 : _a.width) {
            viewPort.width = options.resolution.width;
        }
        if ((_b = options.resolution) === null || _b === void 0 ? void 0 : _b.height) {
            viewPort.height = options.resolution.height;
        }
        viewPort.isMobile = !!options.mobile;
        viewPort.isLandscape = (_c = options.landscape) !== null && _c !== void 0 ? _c : viewPort.width > viewPort.height;
        viewPort.hasTouch = !!options.mobile;
        return viewPort;
    }
    async getSourceHtml(url, options) {
        try {
            const fetchOptions = {
                headers: {
                    'User-Agent': options
                        ? options.userAgent
                            ? options.userAgent
                            : options.mobile
                                ? constants_1.DEFAULT_MOBILE_USER_AGENT
                                : constants_1.DEFAULT_DESKTOP_USER_AGENT
                        : constants_1.DEFAULT_DESKTOP_USER_AGENT
                }
            };
            const response = await fetch(url, fetchOptions);
            return (await response.text()).trim();
        }
        catch (e) {
            return '';
        }
    }
    async getValidatorResult(url) {
        if (this.endpoint) {
            const validationUrl = this.endpoint + encodeURIComponent(url);
            try {
                const response = await axios_1.default.get(validationUrl, { timeout: 10 * 1000 });
                if (response && response.status === 200) {
                    return response.data;
                }
            }
            catch (e) {
                console.error('Error fetching HTML Validation: ' + e);
            }
        }
        return undefined;
    }
    validatorNeeded(options) {
        if (this.isModuleSetToExecute(options, 'wcag') && this.endpoint) {
            if (options['wcag-techniques']) {
                if (this.moduleExcludesValidatorTechnique(options)) {
                    return false;
                }
                else if (options['wcag-techniques'].techniques) {
                    return this.moduleIncludesValidatorTechnique(options);
                }
            }
            return true;
        }
        return false;
    }
    isModuleSetToExecute(options, module) {
        return !options.execute || (options.execute && !!options.execute[module]);
    }
    moduleIncludesValidatorTechnique(options) {
        return !!(options &&
            options['wcag-techniques'] &&
            options['wcag-techniques'].techniques &&
            (options['wcag-techniques'].techniques.includes('QW-WCAG-T16') ||
                options['wcag-techniques'].techniques.includes('H88')));
    }
    moduleExcludesValidatorTechnique(options) {
        return !!(options &&
            options['wcag-techniques'] &&
            options['wcag-techniques'].exclude &&
            (options['wcag-techniques'].exclude.includes('QW-WCAG-T16') || options['wcag-techniques'].exclude.includes('H88')));
    }
    sourceHTMLNeeded(options) {
        if (this.isModuleSetToExecute(options, 'act')) {
            if (options['act-rules']) {
                if (this.moduleExcludesSourceCodeRule(options)) {
                    return false;
                }
                else if (options['act-rules'].rules) {
                    return this.moduleIncludesSourceCodeRule(options);
                }
            }
            return true;
        }
        return false;
    }
    moduleIncludesSourceCodeRule(options) {
        return !!(options &&
            options['act-rules'] &&
            options['act-rules'].rules &&
            (options['act-rules'].rules.includes('QW-ACT-R4') ||
                options['act-rules'].rules.includes('bc659a') ||
                options['act-rules'].rules.includes('QW-ACT-R71') ||
                options['act-rules'].rules.includes('bisz58')));
    }
    moduleExcludesSourceCodeRule(options) {
        return !!(options &&
            options['act-rules'] &&
            options['act-rules'].exclude &&
            (options['act-rules'].exclude.includes('QW-ACT-R4') ||
                options['act-rules'].exclude.includes('bc659a') ||
                options['act-rules'].exclude.includes('QW-ACT-R71') ||
                options['act-rules'].exclude.includes('bisz58')));
    }
    isHtmlDocument(content, url) {
        if (url && (url.endsWith('.svg') || url.endsWith('.xml') || url.endsWith('.xhtml'))) {
            return false;
        }
        return !(((content === null || content === void 0 ? void 0 : content.trim().startsWith('<math')) || (content === null || content === void 0 ? void 0 : content.trim().startsWith('<svg'))) &&
            !(content === null || content === void 0 ? void 0 : content.includes('<html')));
    }
}
exports.Dom = Dom;
//# sourceMappingURL=index.js.map