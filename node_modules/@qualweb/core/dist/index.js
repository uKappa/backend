"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFileUrls = exports.generateEARLReport = exports.QualWeb = void 0;
const puppeteer_extra_1 = __importDefault(require("puppeteer-extra"));
const puppeteer_cluster_1 = require("puppeteer-cluster");
const puppeteer_extra_plugin_stealth_1 = __importDefault(require("puppeteer-extra-plugin-stealth"));
const puppeteer_extra_plugin_adblocker_1 = __importDefault(require("puppeteer-extra-plugin-adblocker"));
const earl_reporter_1 = require("@qualweb/earl-reporter");
Object.defineProperty(exports, "generateEARLReport", { enumerable: true, get: function () { return earl_reporter_1.generateEARLReport; } });
const dom_1 = require("@qualweb/dom");
const evaluation_1 = require("@qualweb/evaluation");
const crawler_1 = require("@qualweb/crawler");
const locale_1 = __importDefault(require("@qualweb/locale"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
require("colors");
class QualWeb {
    constructor(plugins) {
        this.qualwebPlugins = [];
        if (plugins === null || plugins === void 0 ? void 0 : plugins.stealth) {
            puppeteer_extra_1.default.use((0, puppeteer_extra_plugin_stealth_1.default)());
        }
        if (plugins === null || plugins === void 0 ? void 0 : plugins.adBlock) {
            puppeteer_extra_1.default.use((0, puppeteer_extra_plugin_adblocker_1.default)({ blockTrackers: true }));
        }
    }
    async start(clusterOptions, puppeteerOptions) {
        var _a, _b, _c;
        this.cluster = await puppeteer_cluster_1.Cluster.launch({
            concurrency: puppeteer_cluster_1.Cluster.CONCURRENCY_CONTEXT,
            maxConcurrency: (_a = clusterOptions === null || clusterOptions === void 0 ? void 0 : clusterOptions.maxConcurrency) !== null && _a !== void 0 ? _a : 1,
            puppeteerOptions: puppeteerOptions,
            puppeteer: puppeteer_extra_1.default,
            timeout: (_b = clusterOptions === null || clusterOptions === void 0 ? void 0 : clusterOptions.timeout) !== null && _b !== void 0 ? _b : 60 * 1000,
            monitor: (_c = clusterOptions === null || clusterOptions === void 0 ? void 0 : clusterOptions.monitor) !== null && _c !== void 0 ? _c : false
        });
    }
    use(plugin) {
        this.qualwebPlugins.push(plugin);
        return this;
    }
    async stop() {
        var _a;
        await ((_a = this.cluster) === null || _a === void 0 ? void 0 : _a.close());
    }
    async evaluate(options) {
        var _a, _b, _c, _d, _e, _f;
        const modulesToExecute = {
            act: true,
            wcag: true,
            bp: true,
            wappalyzer: false,
            counter: false
        };
        const urls = await this.checkUrls(options);
        if ((options.html === undefined || options.html.trim() === '') && urls.length === 0) {
            throw new Error('Invalid input method');
        }
        this.handleLocales(options);
        if (options.execute) {
            modulesToExecute.act = !!options.execute.act;
            modulesToExecute.wcag = !!options.execute.wcag;
            modulesToExecute.bp = !!options.execute.bp;
            modulesToExecute.wappalyzer = !!options.execute.wappalyzer;
            modulesToExecute.counter = !!options.execute.counter;
        }
        const evaluations = {};
        let foundError = false;
        const timestamp = new Date().getTime();
        handleError(options, 'Evaluation errors', new Date(timestamp).toISOString().replace(/T/, ' ').replace(/\..+/, '') + '\n-----------', timestamp);
        (_a = this.cluster) === null || _a === void 0 ? void 0 : _a.on('taskerror', (err, data) => {
            foundError = true;
            handleError(options, data.url, err.message + '\n-----------', timestamp);
        });
        await ((_b = this.cluster) === null || _b === void 0 ? void 0 : _b.task(async ({ page, data: { url, html } }) => {
            const dom = new dom_1.Dom(page, options.validator);
            for (const plugin of this.qualwebPlugins) {
                if (typeof plugin.beforePageLoad === 'function') {
                    await plugin.beforePageLoad(page, url || 'customHtml');
                }
            }
            const { sourceHtml, validation } = await dom.process(options, url !== null && url !== void 0 ? url : '', html !== null && html !== void 0 ? html : '');
            const evaluation = new evaluation_1.Evaluation(url, page, modulesToExecute);
            for (const plugin of this.qualwebPlugins) {
                if (typeof plugin.afterPageLoad === 'function') {
                    await plugin.afterPageLoad(page, url || 'customHtml');
                }
            }
            const evaluationReport = await evaluation.evaluatePage(sourceHtml, options, validation);
            evaluations[url || 'customHtml'] = evaluationReport.getFinalReport();
        }));
        for (const url of urls) {
            (_c = this.cluster) === null || _c === void 0 ? void 0 : _c.queue({ url });
        }
        if (options.html) {
            (_d = this.cluster) === null || _d === void 0 ? void 0 : _d.queue({ html: options.html });
        }
        await ((_e = this.cluster) === null || _e === void 0 ? void 0 : _e.idle());
        if ((_f = options.log) === null || _f === void 0 ? void 0 : _f.file) {
            if (foundError) {
                console.warn('One or more urls failed to evaluate. Check the error.log for more information.'.yellow);
            }
            else {
                deleteErrorLogFile(timestamp);
            }
        }
        return evaluations;
    }
    async crawl(domain, options, viewport, waitUntil) {
        const browser = await puppeteer_extra_1.default.launch();
        const incognito = await browser.createIncognitoBrowserContext();
        const crawler = new crawler_1.Crawler(incognito, domain, viewport, waitUntil);
        await crawler.crawl(options);
        const results = crawler.getResults();
        await incognito.close();
        await browser.close();
        return results;
    }
    async checkUrls(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const urls = new Array();
        if (options.url) {
            urls.push(decodeURIComponent(options.url).trim());
        }
        if (options.urls) {
            urls.push(...options.urls.map((url) => decodeURIComponent(url).trim()));
        }
        if (options.file) {
            urls.push(...(await getFileUrls(options.file)));
        }
        if (options.crawl) {
            const viewport = {
                width: 0,
                height: 0,
                isMobile: false,
                isLandscape: true
            };
            if (options.viewport) {
                viewport.width = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.viewport) === null || _a === void 0 ? void 0 : _a.resolution) === null || _b === void 0 ? void 0 : _b.width) !== null && _c !== void 0 ? _c : 0;
                viewport.height = (_f = (_e = (_d = options === null || options === void 0 ? void 0 : options.viewport) === null || _d === void 0 ? void 0 : _d.resolution) === null || _e === void 0 ? void 0 : _e.height) !== null && _f !== void 0 ? _f : 0;
                viewport.isMobile = (_h = (_g = options === null || options === void 0 ? void 0 : options.viewport) === null || _g === void 0 ? void 0 : _g.mobile) !== null && _h !== void 0 ? _h : false;
                viewport.isLandscape = (_k = (_j = options === null || options === void 0 ? void 0 : options.viewport) === null || _j === void 0 ? void 0 : _j.landscape) !== null && _k !== void 0 ? _k : true;
            }
            urls.push(...(await this.crawl(options.crawl, options.crawlOptions, viewport.width + viewport.height !== 0 ? viewport : undefined, options.waitUntil)));
        }
        return urls;
    }
    handleLocales(options) {
        if (options.translate) {
            if (typeof options.translate === 'string') {
                if (Object.keys(locale_1.default).includes(options.translate)) {
                    options.translate = {
                        translate: locale_1.default[options.translate],
                        fallback: locale_1.default.en
                    };
                }
                else {
                    throw new Error(`Locale "${options.translate}" not supported.`);
                }
            }
            else if (Object.keys(options.translate).includes('translate')) {
                this.verifyTranslationObject(options);
            }
            else {
                options.translate = {
                    translate: options.translate,
                    fallback: locale_1.default.en
                };
            }
        }
        else {
            options.translate = {
                translate: locale_1.default.en,
                fallback: locale_1.default.en
            };
        }
    }
    verifyTranslationObject(options) {
        if (typeof options.translate.translate === 'string') {
            if (Object.keys(locale_1.default).includes(options.translate.translate)) {
                options.translate = {
                    translate: locale_1.default[options.translate.translate],
                    fallback: locale_1.default.en
                };
            }
            else {
                throw new Error(`Locale "${options.translate.translate}" not supported.`);
            }
        }
        if (typeof options.translate.fallback === 'string') {
            if (Object.keys(locale_1.default).includes(options.translate.fallback)) {
                options.translate.fallback =
                    locale_1.default[options.translate.fallback];
            }
            else {
                throw new Error(`Locale "${options.translate.fallback}" not supported.`);
            }
        }
    }
}
exports.QualWeb = QualWeb;
async function getFileUrls(file) {
    const content = await readFileData(file);
    return content
        .split('\n')
        .map((url) => {
        try {
            return decodeURIComponent(url).trim();
        }
        catch (_err) {
            return '';
        }
    })
        .filter((url) => url.trim() !== '');
}
exports.getFileUrls = getFileUrls;
function readFileData(file) {
    return new Promise((resolve, reject) => {
        (0, fs_1.readFile)(file, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data.toString('utf-8'));
            }
        });
    });
}
function handleError(options, url, message, timestamp) {
    if (options.log && options.log.file) {
        (0, fs_1.writeFile)(path_1.default.resolve(process.cwd(), `qualweb-errors-${timestamp}.log`), url + ' : ' + message + '\n', { flag: 'a', encoding: 'utf-8' }, (err) => {
            if (err) {
                console.error(err);
            }
        });
    }
    if (options.log && options.log.console) {
        console.error(url + ' : ' + message + '\n');
    }
}
function deleteErrorLogFile(timestamp) {
    (0, fs_1.unlink)(path_1.default.resolve(process.cwd(), `qualweb-errors-${timestamp}.log`), (err) => {
        if (err) {
            throw err;
        }
    });
}
//# sourceMappingURL=index.js.map