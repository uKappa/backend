"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvaluationRecord = exports.Evaluation = void 0;
const crypto_1 = require("crypto");
const evaluationRecord_object_1 = __importDefault(require("./evaluationRecord.object"));
exports.EvaluationRecord = evaluationRecord_object_1.default;
class Evaluation {
    constructor(url, page, execute) {
        this.url = url;
        this.page = page;
        this.execute = execute;
    }
    async evaluatePage(sourceHtml, options, validation) {
        const evaluator = await this.getEvaluator();
        const evaluation = new evaluationRecord_object_1.default(evaluator);
        await this.init();
        const locale = options.translate;
        try {
            if (this.execute.act) {
                evaluation.addModuleEvaluation('act-rules', await this.executeACT(sourceHtml, locale, options['act-rules']));
            }
        }
        catch (error) {
            console.log('Error in ACT-Rules');
            console.log(error);
        }
        try {
            if (this.execute.wcag) {
                evaluation.addModuleEvaluation('wcag-techniques', await this.executeWCAG(locale, validation, options['wcag-techniques']));
            }
        }
        catch (error) {
            console.log('Error in WCAG-Techniques');
            console.log(error);
        }
        try {
            if (this.execute.bp) {
                evaluation.addModuleEvaluation('best-practices', await this.executeBP(locale, options['best-practices']));
            }
        }
        catch (error) {
            console.log('Error in Best Practices');
            console.log(error);
        }
        try {
            if (this.execute.counter) {
                evaluation.addModuleEvaluation('counter', await this.executeCounter());
            }
        }
        catch (error) {
            console.log('Error in Counter');
            console.log(error);
        }
        return evaluation;
    }
    async getEvaluator() {
        const [plainHtml, pageTitle, elements, browserUserAgent] = await Promise.all([
            this.page.evaluate(() => {
                return document.documentElement.outerHTML;
            }),
            this.page.title(),
            this.page.$$('*'),
            this.page.browser().userAgent()
        ]);
        const viewport = this.page.viewport();
        return {
            name: 'QualWeb',
            description: 'QualWeb is an automatic accessibility evaluator for webpages.',
            version: '3.0.0',
            homepage: 'http://www.qualweb.di.fc.ul.pt/',
            date: new Date().toISOString().replace(/T/, ' ').replace(/\..+/, ''),
            hash: (0, crypto_1.randomBytes)(64).toString('hex'),
            url: this.url ? this.parseUrl() : undefined,
            page: {
                viewport: {
                    mobile: viewport === null || viewport === void 0 ? void 0 : viewport.isMobile,
                    landscape: viewport === null || viewport === void 0 ? void 0 : viewport.isLandscape,
                    userAgent: browserUserAgent,
                    resolution: {
                        width: viewport === null || viewport === void 0 ? void 0 : viewport.width,
                        height: viewport === null || viewport === void 0 ? void 0 : viewport.height
                    }
                },
                dom: {
                    html: plainHtml,
                    title: pageTitle,
                    elementCount: elements.length
                }
            }
        };
    }
    parseUrl() {
        const inputUrl = this.url;
        const completeUrl = this.page.url() !== 'about:blank' ? this.page.url() : this.url;
        const urlObject = new URL(completeUrl);
        const protocol = urlObject.protocol.split(':')[0];
        const domainName = urlObject.origin.split('/')[2];
        const tmp = domainName.split('.');
        const domain = tmp[tmp.length - 1];
        const uri = urlObject.pathname;
        return {
            inputUrl,
            protocol,
            domainName,
            domain,
            uri,
            completeUrl
        };
    }
    async init() {
        await this.page.addScriptTag({
            path: require.resolve('@qualweb/qw-page'),
            type: 'text/javascript'
        });
        await this.page.addScriptTag({
            path: require.resolve('@qualweb/util'),
            type: 'text/javascript'
        });
    }
    async executeACT(sourceHtml, locale, options) {
        await this.page.addScriptTag({
            path: require.resolve('@qualweb/act-rules'),
            type: 'text/javascript'
        });
        await this.page.keyboard.press('Tab');
        await this.page.evaluate((sourceHtml, locale, options) => {
            window.act = new ACTRules(JSON.parse(locale), options);
            window.act.validateFirstFocusableElementIsLinkToNonRepeatedContent();
            const parser = new DOMParser();
            const sourceDoc = parser.parseFromString('', 'text/html');
            sourceDoc.documentElement.innerHTML = sourceHtml;
            const elements = sourceDoc.querySelectorAll('meta');
            const metaElements = new Array();
            elements.forEach((element) => {
                metaElements.push(window.qwPage.createQWElement(element));
            });
            window.act.validateMetaElements(metaElements);
            window.act.executeAtomicRules();
            window.act.executeCompositeRules();
        }, sourceHtml, JSON.stringify(locale), options);
        if (!options ||
            ((!options.rules || options.rules.includes('QW-ACT-R40') || options.rules.includes('59br37')) &&
                (!options.exclude || !options.exclude.includes('QW-ACT-R40') || !options.exclude.includes('59br37')))) {
            const viewport = this.page.viewport();
            await this.page.setViewport({
                width: 640,
                height: 512,
                isMobile: viewport === null || viewport === void 0 ? void 0 : viewport.isMobile,
                isLandscape: viewport === null || viewport === void 0 ? void 0 : viewport.isLandscape,
                hasTouch: viewport === null || viewport === void 0 ? void 0 : viewport.hasTouch
            });
            await this.page.evaluate(() => {
                window.act.validateZoomedTextNodeNotClippedWithCSSOverflow();
            });
            if (viewport) {
                await this.page.setViewport(viewport);
            }
        }
        return this.page.evaluate(() => {
            return window.act.getReport();
        });
    }
    async executeWCAG(locale, validation, options) {
        await this.page.addScriptTag({
            path: require.resolve('@qualweb/wcag-techniques'),
            type: 'text/javascript'
        });
        const newTabWasOpen = await this.detectIfUnwantedTabWasOpened();
        return await this.page.evaluate((locale, newTabWasOpen, validation, options) => {
            window.wcag = new WCAGTechniques(JSON.parse(locale), options);
            return window.wcag.execute(newTabWasOpen, validation);
        }, JSON.stringify(locale), newTabWasOpen, validation, options);
    }
    async executeBP(locale, options) {
        await this.page.addScriptTag({
            path: require.resolve('@qualweb/best-practices'),
            type: 'text/javascript'
        });
        return await this.page.evaluate((locale, options) => {
            const bp = new BestPractices(JSON.parse(locale), options);
            return bp.execute();
        }, JSON.stringify(locale), options);
    }
    async executeCounter() {
        await this.page.addScriptTag({
            path: require.resolve('@qualweb/counter'),
            type: 'text/javascript'
        });
        return this.page.evaluate(() => {
            return window.executeCounter();
        });
    }
    async detectIfUnwantedTabWasOpened() {
        const tabs = await this.page.browser().pages();
        let wasOpen = false;
        for (const tab of tabs !== null && tabs !== void 0 ? tabs : []) {
            const target = tab.target();
            const opener = target.opener();
            if (opener) {
                const openerPage = await opener.page();
                if (openerPage && openerPage.url() === this.page.url()) {
                    wasOpen = true;
                    await tab.close();
                }
            }
        }
        return wasOpen;
    }
}
exports.Evaluation = Evaluation;
//# sourceMappingURL=index.js.map